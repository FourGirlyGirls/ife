

var fs    = require('fs'),
    path  = require('path'),
    zlib  = require('zlib'),
    mime  = require('mime'),
    cache = {}

function handleBusiness(basePath, opts) {
  this.basePath = basePath||''
  this.options  = { cache:false, compress:true, redis:false }
  for (opt in opts) this.set(opt, opts[opt])
}

handleBusiness.prototype.set = function(option, value) {
  if (typeof option === 'object' && (!option instanceof Array)) {
    for (opt in option) this.set(opt, option[opt])
  }else {
    if (this.options.hasOwnProperty(option))
      this.options[option] = value
    if (option==='redis'&&value===true) {
      this.options['cache'] = true
      cache = require('redis').createClient()
    }
  }
  return this
}

handleBusiness.prototype.serveFile = function(file, rObj, req, res) { 
  res.writeHead(200, rObj) 
  res.end(file)
}


handleBusiness.prototype.getAvailableEncoding = function(req) {
  var aE = req.headers['accept-encoding']||''
  if (/deflate/i.test(aE)) return 'deflate'
  else if (/gzip/i.test(aE)) return 'gzip'
  else return null
}

handleBusiness.prototype.serve = function(fileName, req, res) {

  var self     = this,
      filePath = path.join(this.basePath, fileName),
      exists   = path.existsSync(filePath)

  if (!exists) { 
    res.writeHead(404)
    res.end()
    return
  }

  var stat         = fs.statSync(filePath),
      etag         = '"'+[stat.ino,stat.size,Date.parse(stat.mtime)].join('-')+'"',
      clientCached = (etag===req.headers['if-none-match'])

  if (clientCached) {
    res.writeHead(304)
    res.end()
    return
  }

  var encType       = this.getAvailableEncoding(req),
      mimeType   = mime.lookup(filePath),
      date       = new Date(),
      rObj       = {'Content-Type':mimeType},
      cachedFile = cache[filePath]

  date.setHours(date.getHours() + 48)

  if (this.options.redis) {
    cache.get(filePath, function(err, data) {
      if (data) return handle(null, data)
      else return fs.readFile(filePath, handle)
    })
  }else if (self.options.cache) {
     if (cachedFile) return handle(null, cachedFile)
     else return fs.readFile(filePath, handle)
  }else return fs.readFile(filePath, handle)

  function handle(err, data) {
    if (data) {
      rObj['Content-Length'] = data.length
      if (self.options.cache) {
      	rObj['Etag'] = etag
	if (self.options.redis) cache.set(filePath, data)
	else cache[filePath] = data
      }
      if (self.options.compress&&encType) {
	rObj['Content-Encoding'] = encType
	zlib[encType](data, function(err, buffer) {
	  if (!err) {
	    return self.serveFile(buffer, rObj, req, res)
	  }else{
	    res.writeHead(404)
	    res.end()
	  }
	})
      }else return self.serveFile(data, rObj, req, res)
    }else {
      res.writeHead(404)
      res.end()
    }
  }
}

module.exports.inter = function(basePath, options) {

  var handler = new handleBusiness(basePath, options)
  var re      = new RegExp('^/'+basePath+'/')
  var bpl     = basePath.length+1

  return function(req, res, next) {
    var path = req.path
    if (re.test(path)) {
      return handler.serve(unescape(path.substring(bpl)), req, res)
    }else return next()
  }

}

module.exports.dir = function(basePath, options) {

  if (basePath instanceof Array) {

    var rObj = {}

    basePath.forEach(function(i) {
      rObj[i] = new handleBusiness(i, options)
    })

    return rObj
  }else return new handleBusiness(basePath, options)

}

module.exports.file = function(path, options) {
  var handler = new handleBusiness('', options)
  return {
    serve:function(req, res) {
      handler.serve(path, req, res)
    }
  }
}
